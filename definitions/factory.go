// Copyright (C) Fasten Health, Inc. - All Rights Reserved.
//
// THIS FILE IS GENERATED BY https://github.com/fastenhealth/fasten-sources-gen
// PLEASE DO NOT EDIT BY HAND

package definitions

import (
	"bytes"
	"embed"
	"fmt"
	"github.com/fastenhealth/fasten-sources/catalog"
	models "github.com/fastenhealth/fasten-sources/definitions/models"
	pkg "github.com/fastenhealth/fasten-sources/pkg"
	modelsCatalog "github.com/fastenhealth/fasten-sources/pkg/models/catalog"
	"gopkg.in/yaml.v3"
)

//go:embed platform/*.yaml
var platformFs embed.FS

type GetSourceConfigOptions struct {
	//One of the following is required: PlatformType or EndpointId
	PlatformType pkg.PlatformType
	EndpointId   string

	//Optional - filter's the endpoint id by the environment (sandbox, prod).
	Env pkg.FastenLighthouseEnvType
	//Optional - sets the Client ID for the SourceConfig
	ClientIdLookup map[pkg.PlatformType]string
}

func GetSourceDefinition(
	options GetSourceConfigOptions,
) (*models.LighthouseSourceDefinition, error) {

	if len(options.PlatformType) > 0 {
		//only manual and fasten can be retrieved directly, all other Endpoint configs are retrieved via the catalog (endpointId -> platformType -> platformDefinition)
		if options.PlatformType == pkg.PlatformTypeManual || options.PlatformType == pkg.PlatformTypeFasten || options.PlatformType == pkg.PlatformTypeHIE {
			platformDefinition, err := getPlatformDefinition(options.PlatformType)
			if err != nil {
				return nil, fmt.Errorf("error retrieving platform definition (%s): %w", options.PlatformType, err)
			}
			return platformDefinition, nil
		} else {
			return nil, fmt.Errorf("unsupported platform type: %s", options.PlatformType)
		}
	} else if len(options.EndpointId) > 0 {
		queryOpts := &modelsCatalog.CatalogQueryOptions{Id: options.EndpointId}
		if len(options.Env) > 0 {
			queryOpts.LighthouseEnvType = options.Env
		}

		endpointLookup, err := catalog.GetEndpoints(queryOpts)
		if err != nil {
			return nil, fmt.Errorf("error retrieving endpoint (%s): %w", options.EndpointId, err)
		}

		if len(endpointLookup) > 1 {
			return nil, fmt.Errorf("error unexpected endpoint lookup length (%d)", len(endpointLookup))
		}
		endpoint := endpointLookup[options.EndpointId]

		//this is the platform that we need to use as the base class.
		platformType := endpoint.GetPlatformType()

		platformDefinition, err := getPlatformDefinition(platformType)
		if err != nil {
			return nil, fmt.Errorf("error retrieving platform definition (%s): %w", platformType, err)
		}
		//platform environment specific customizations happen in Populate method
		platformDefinition.Populate(&endpoint, options.Env, options.ClientIdLookup)

		return platformDefinition, err
	} else {
		return nil, fmt.Errorf("PlatformType or EndpointID are required")
	}

}

func getPlatformDefinition(platformType pkg.PlatformType) (*models.LighthouseSourceDefinition, error) {

	if platformType == pkg.PlatformTypeManual {
		return &models.LighthouseSourceDefinition{PatientAccessEndpoint: &modelsCatalog.PatientAccessEndpoint{PlatformType: string(pkg.PlatformTypeManual)}}, nil
	} else if platformType == pkg.PlatformTypeFasten {
		return &models.LighthouseSourceDefinition{PatientAccessEndpoint: &modelsCatalog.PatientAccessEndpoint{PlatformType: string(pkg.PlatformTypeFasten)}}, nil
	} else if platformType == pkg.PlatformTypeHIE {
		return &models.LighthouseSourceDefinition{PatientAccessEndpoint: &modelsCatalog.PatientAccessEndpoint{PlatformType: string(pkg.PlatformTypeHIE)}}, nil
	}

	platformDefinition, err := strictUnmarshalYaml(platformType)

	if err != nil {
		return nil, fmt.Errorf("error retrieving platform definition (%s): %w", platformType, err)
	}

	return platformDefinition, nil
}

func strictUnmarshalYaml(platformType pkg.PlatformType) (*models.LighthouseSourceDefinition, error) {
	embeddedFilename := fmt.Sprintf("platform/%s.yaml", platformType)

	fileBytes, err := platformFs.ReadFile(embeddedFilename)
	if err != nil {
		return nil, fmt.Errorf("failed to read embedded %s: %w", embeddedFilename, err)
	}

	var platformDefinition models.LighthouseSourceDefinition

	decoder := yaml.NewDecoder(bytes.NewReader(fileBytes))
	decoder.KnownFields(true)
	err = decoder.Decode(&platformDefinition)
	return &platformDefinition, err
}
