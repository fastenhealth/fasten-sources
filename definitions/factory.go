// Copyright (C) Fasten Health, Inc. - All Rights Reserved.
//
// THIS FILE IS GENERATED BY https://github.com/fastenhealth/fasten-sources-gen
// PLEASE DO NOT EDIT BY HAND

package definitions

import (
	"bytes"
	"embed"
	"fmt"
	"github.com/fastenhealth/fasten-sources/catalog"
	models "github.com/fastenhealth/fasten-sources/definitions/models"
	pkg "github.com/fastenhealth/fasten-sources/pkg"
	modelsCatalog "github.com/fastenhealth/fasten-sources/pkg/models/catalog"
	"gopkg.in/yaml.v3"
	"log"
	"strings"
)

//go:embed platform/*.yaml
var platformFs embed.FS

type SourceDefinitionOptions struct {
	//One of the following is required: PlatformType or EndpointId
	PlatformType         pkg.PlatformType
	PlatformTypeOverride pkg.PlatformType
	EndpointId           string

	//Optional - filter's the endpoint id by the environment (sandbox, prod).
	Env pkg.FastenLighthouseEnvType
	//Optional - sets the Client ID for the SourceConfig
	ClientIdLookupFn func(pkg.PlatformType, string, pkg.FastenLighthouseEnvType) string

	//Optional - post-Populate hook can be used to further customize the SourceDefinition
	PostPopulateFn func(*models.LighthouseSourceDefinition)
}

func WithPlatformType(platformType pkg.PlatformType) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		o.PlatformType = platformType
	}
}

// This function is used to override the platform type specified in the Endpoint Definition.
// It should only be done in the case of TEFCA Facilitated FHIR
func WithPlatformTypeOverride(platformTypeOverride pkg.PlatformType) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		if !strings.HasPrefix(string(platformTypeOverride), "tefca-") {
			log.Printf("ERROR: PlatformTypeOverride is not a TEFCA platform type (%s), Ignoring", platformTypeOverride)
		} else {
			o.PlatformTypeOverride = platformTypeOverride
		}
	}
}

func WithEndpointId(endpointId string) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		o.EndpointId = endpointId
	}
}

func WithEnv(env pkg.FastenLighthouseEnvType) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		o.Env = env
	}
}

// deprecated
func WithClientIdLookup(lookup map[pkg.PlatformType]string) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		o.ClientIdLookupFn = func(platformType pkg.PlatformType, endpointId string, envType pkg.FastenLighthouseEnvType) string {
			if clientId, ok := lookup[platformType]; ok {
				return clientId
			} else {
				return "" //noop
			}
		}
	}
}

func WithClientIdLookupFn(lookup func(pkg.PlatformType, string, pkg.FastenLighthouseEnvType) string) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		o.ClientIdLookupFn = lookup
	}
}

func WithPostPopulateFn(postPopulateFn func(*models.LighthouseSourceDefinition)) func(*SourceDefinitionOptions) {
	return func(o *SourceDefinitionOptions) {
		o.PostPopulateFn = postPopulateFn
	}
}

func GetSourceDefinition(
	defOptions ...func(options *SourceDefinitionOptions),
	// options SourceDefinitionOptions,
) (*models.LighthouseSourceDefinition, error) {

	options := &SourceDefinitionOptions{
		ClientIdLookupFn: func(pkg.PlatformType, string, pkg.FastenLighthouseEnvType) string {
			return "" //noop
		},
		PostPopulateFn: func(definition *models.LighthouseSourceDefinition) {
			return //noop
		},
	}
	for _, o := range defOptions {
		o(options)
	}

	if len(string(options.PlatformType)) > 0 {
		//only manual and fasten can be retrieved directly, all other Endpoint configs are retrieved via the catalog (endpointId -> platformType -> platformDefinition)
		if options.PlatformType == pkg.PlatformTypeManual || options.PlatformType == pkg.PlatformTypeFasten || options.PlatformType == pkg.PlatformTypeTEFCA {
			platformDefinition, err := getPlatformDefinition(options.PlatformType)
			if err != nil {
				return nil, fmt.Errorf("error retrieving platform definition (%s): %w", options.PlatformType, err)
			}
			return platformDefinition, nil
		} else {
			return nil, fmt.Errorf("unsupported platform type: %s", options.PlatformType)
		}
	} else if len(options.EndpointId) > 0 {
		log.Printf("retrieving endpoint definition for %s", options.EndpointId)
		queryOpts := &modelsCatalog.CatalogQueryOptions{Id: options.EndpointId}
		if len(options.Env) > 0 {
			queryOpts.LighthouseEnvType = options.Env
		}

		endpointLookup, err := catalog.GetEndpoints(queryOpts)
		if err != nil {
			return nil, fmt.Errorf("error retrieving endpoint (%s): %w", options.EndpointId, err)
		}

		if len(endpointLookup) > 1 {
			return nil, fmt.Errorf("error unexpected endpoint lookup length (%d)", len(endpointLookup))
		}
		endpoint := endpointLookup[options.EndpointId]

		//this is the platform that we need to use as the base class.
		platformType := endpoint.GetPlatformType()
		if len(options.PlatformTypeOverride) > 0 {
			platformType = options.PlatformTypeOverride
			endpoint.PlatformType = string(platformType) //override the platform type in the endpoint
		}

		platformDefinition, err := getPlatformDefinition(platformType)
		if err != nil {
			return nil, fmt.Errorf("error retrieving platform definition (%s): %w", platformType, err)
		}
		//platform environment specific customizations happen in Populate method
		platformDefinition.Populate(&endpoint, options.Env, options.ClientIdLookupFn(platformType, options.EndpointId, options.Env))

		if options.PostPopulateFn != nil {
			options.PostPopulateFn(platformDefinition)
		}

		return platformDefinition, err
	} else {
		return nil, fmt.Errorf("PlatformType or EndpointID are required")
	}

}

func getPlatformDefinition(platformType pkg.PlatformType) (*models.LighthouseSourceDefinition, error) {

	if platformType == pkg.PlatformTypeManual {
		return &models.LighthouseSourceDefinition{PatientAccessEndpoint: &modelsCatalog.PatientAccessEndpoint{PlatformType: string(pkg.PlatformTypeManual)}}, nil
	} else if platformType == pkg.PlatformTypeFasten {
		return &models.LighthouseSourceDefinition{PatientAccessEndpoint: &modelsCatalog.PatientAccessEndpoint{PlatformType: string(pkg.PlatformTypeFasten)}}, nil
	} else if platformType == pkg.PlatformTypeTEFCA {
		return &models.LighthouseSourceDefinition{PatientAccessEndpoint: &modelsCatalog.PatientAccessEndpoint{PlatformType: string(pkg.PlatformTypeTEFCA)}}, nil
	}

	platformDefinition, err := strictUnmarshalYaml(platformType)

	if err != nil {
		return nil, fmt.Errorf("error retrieving platform definition (%s): %w", platformType, err)
	}

	return platformDefinition, nil
}

func strictUnmarshalYaml(platformType pkg.PlatformType) (*models.LighthouseSourceDefinition, error) {
	embeddedFilename := fmt.Sprintf("platform/%s.yaml", platformType)

	fileBytes, err := platformFs.ReadFile(embeddedFilename)
	if err != nil {
		return nil, fmt.Errorf("failed to read embedded %s: %w", embeddedFilename, err)
	}

	var platformDefinition models.LighthouseSourceDefinition

	decoder := yaml.NewDecoder(bytes.NewReader(fileBytes))
	decoder.KnownFields(true)
	err = decoder.Decode(&platformDefinition)
	return &platformDefinition, err
}
